---
title: "Evaluating Vector Control" 
subtitle: "Dynamical Time Series Analysis " 
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document 
vignette: >
  %\VignetteIndexEntry{Evaluating Vector Control}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, warning=FALSE, message=FALSE}
library(ramp.xds)
library(Matrix)
library(expm)
library(ramp.library)
library(ramp.control)
library(ramp.work)
```


```{r, echo=FALSE} 
devtools::load_all()
```

Routine evaluation of vector control for malaria presents enormous challenges. This vignette considers the challenge of evaluating the impact of mass bed net distributions and mass indoor house spraying (*i.e.* indoor residual spraying, or IRS). 

The vignette has two parts:

+ **demo** -- an example that uses **`ramp.work`** to evaluate control 

+ **design** -- for the `dev` users 

## Demo 


To evaluate vector control, we need to do the following tasks:

1. Build a model

2. Set up model fitting 

3. Set up vector control

4. Fit the model to data 

5. Construct a counterfactual baseline

6. Compute the impact  


### 1. Build a Model

We want to understand malaria as a *changing baseline* that has been *modified by vector control.* The malaria baseline is affected by *mosquito ecology.* To get started, we build a model to understand malaria prevalence in relation to exposure. We set up a model that is forced by the EIR:

```{r xds_setup}
sip_si <- xds_setup_eir(Xname = "SIP")
```

### 2. Set Up Model Fitting

The functions that set up model fitting in **`ramp.work`** use `xds_scaling` to make some initial guesses about the mean forcing parameters and the seasonal phase. 

```{r xds_scaling}
sip_si <- xds_scaling(sip_si)
plot_eirpr(sip_si)
```

After fitting the model and getting the seasonal pattern right, it might be worth it to run `xds_scaling` again. 

To set up model fitting, we need some data. We use a time series we have saved locally:

```{r read data}
prts <- read.table("pfpr_time_series.tbl")
with(prts, {
  plot(jdates, pfpr, ylim = c(0,0.65), main = "Example", xlab = "Julian Date (day 1 is Jan 1, 2015)", ylab = "PR", xlim = range(0, jdates)) 
  lines(jdates, pfpr)
})
```
```{r setup_fitting}
sip_si <- setup_fitting(sip_si, prts$pfpr, prts$jdate)
```

### 3. Set Up Vector Control

To set up vector control for IRS, we use `setup_irs_events` and pass it the Julian dates, the pesticides, and the coverage (% of houses sprayed). 

```{r irs events}
irs_jdates <- c(2861, 3256, 3622) 
irs_type <- c("fludora_fusion", "actellic", "actellic") 
frac_sprayed <- c(.95, .95, .95) 
sip_si <- setup_irs_events(sip_si, irs_jdates, irs_type, frac_sprayed)
```

To set up vector control for bed nets, we use `setup_bednet_events` and pass it the Julian dates, the net types, and peak access: 

```{r bed net events}
bednet_jdates <- c(-200, 776, 2176, 3240)
bednet_type <- rep("pbo", 4)
bednet_peak <- rep(0.95, 4)
sip_si <- setup_bednet_events(sip_si, bednet_jdates, bednet_type, bednet_peak)
```

Before we do any fitting, we want to take a look at the $t$-values of the interpolation points. The default spacing is once a year, but if we want to evaluate vector control, we might want values at sensible points before and after the mass distribution events. There's a lot going on in the following:

+ The *Pf*PR time series is a set of squares

+ The line shows the model with preliminary guesses 

+ The vertical lines show the timing of mass distribution / spraying events:

    - irs is in blue
    
    - bednets is in red
    
    - the # describes the round (there's a bednet found before our data start)
    
    - the text describes the round
    
+ the $\oplus$ symbols show the original spline $t$-values

+ the purple squares are an alternative spacing for the $t$-values returned by `event_chop_spline_t`  

```{r}
show_events(sip_si, mx = 0.4)
ti <- event_chop_spline_t(sip_si, fu=180, b4=60, mngp=80)
points(ti, 0*ti, pch = 15, col = "purple")
```
To set the stage for evaluating, we'll shift the spacing of the time points to the purple squares. 

```{r}
sip_si <- fitting_replace_spline_t(ti, sip_si)
```

### 4. Fit the Model 

Now we fit the model to the data. 

```{r, eval=F}
sip_si <- pr2history_xm(sip_si)
```
```{r, eval=F, echo=FALSE}
sip_si <- pr2history_xm(sip_si)
saveRDS(sip_si, "evaluate.rds")
```

```{r, echo=FALSE}
sip_si <- readRDS("evaluate.rds")
```
```{r}
show_events(sip_si, mx=0.4)
```


### 5 Counterfactual Baseline

To evaluate vector control, we have to grapple with the problem of understanding malaria transmission as a *changing baseline* that has been *modified by control.* The challenge for malaria is that every place is different, so we have to learn about each place. The information we have about malaria is limited. What would have happened in the absence of any control?  

> If all we have is a time series that describes a reality that has been modified by control, what information do we have about the unmodified baseline? 

In this time series, we note the large gaps between mass distribution events. Perhaps we can use these gaps to make some good guesses about the baseline. 
This function computes the time since the last event for each time node.  

```{r}
last_event = function(xds_obj){
  N = length(xds_obj$data$tt)
  last = rep(0, N)
  for(i in 2:N){
    delta = xds_obj$data$tt[i] - c(xds_obj$bednet_obj$events$jdate, xds_obj$irs_obj$events$jdate)
    last[i] = min(delta[delta>0])
  }
  return(last)
}
```

If we use the arbitrary cutoff of a year, we find a set of five values for the interpolation points that we trust.  

```{r}
last_event(sip_si)
which(last_event(sip_si)>365) -> my_ix
my_ix
```


However you decide to impute a new value, you need to update a model with those values. For this there are a few utilities. So what happens if we take the first The first one gets the $t,y$ values and their indices from the object: 

```{r impute cf baseline}
fitting_get_spline_ty(sip_si)$yy[my_ix] -> trusted_y
new_y <- rep(mean(trusted_y), 6)
fitting_change_spline_y(new_y, c(4,7, 9, 10, 11, 12), sip_si) -> sip_si1 
```

### 6. Compute Impact

Now we have a model that describes what we observed, and another that imputes a counterfactual baseline. We can plot the imputed prevalence for the two models. Since malaria is dynamically changing, and since the intervention changed the system in one way, with effects that were observed at another, we can simply plot the outputs: 

```{r}
last_day <- max(prts$jdates)
first_day <- min(prts$jdates)
tm <- c(first_day:last_day)
sip_si <- xds_solve(sip_si, times = tm)
sip_si1 <- xds_solve(sip_si1, times = tm)
xds_plot_PR(sip_si, clrs="darkblue")
xds_plot_PR(sip_si1, clrs="darkred", add=T)
```

## Design 


## Ignore 

It might be useful to use `show_events` to figure out which values you might want to change. 

If you want to replace an entire set: 

+ `fitting_replace_spline_y` to replace all the $y$ values

```{r, eval=F}
y1 <- fitting_get_spline_ty(sip_si1)$yy
sip_si2 <- fitting_replace_spline_y(sqrt(y1), sip_si1)
y2 <- fitting_get_spline_ty(sip_si2)$yy
sum(y2^2 - y1) +1
```

+ `fitting_replace_spline_t` to replace all the $t$ values (the $y$-values get updated by calling `F_trend`)

This was demonstrated above. 

+ `fitting_replace_spline_ty` to replace all the $t,y$ pairs


+ `fitting_change_spline_y` to change all some of $y$ values 

```{r, eval=F}
y1.4 = y1[4]
sip_si3 <- fitting_change_spline_y(y1.4^2, 4, sip_si1)
y3.4 <- fitting_get_spline_ty(sip_si3)$yy[4]
c(y1.4, sqrt(y3.4)) 
```

+ `fitting_change_spline_t` to change some of the $t$ values (the $y$-values get updated by calling `F_trend`)

+ `fitting_change_spline_ty` to change some of the $t,y$ pairs


