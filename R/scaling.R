
#' @title Compute eir-pr scaling relationships
#' @description This function calls [xde_solve_cohort] computes average annual values for the eir, the pr, and other
#' interesting terms and returns a table. It is computed for a model of class "cohort"
#' @param model a list that defines an `ramp.xds` model generated by `xde_setup_cohort()`
#' @param N an integer
#' @param rbr the relative biting rate for a population stratum
#' @importFrom ramp.xds set_eir
#' @importFrom utils tail
#' @return **`xds`** model object
#' @export
xde_scaling_cohort= function(model, N=25, rbr=1){

  aEIR = 10^seq(-1, 3, length.out=N)
  pr = ni = eir = rep(0, N)
  scaling = list()
  for(i in 1:N){
    model <- ramp.xds::set_eir(rbr*aEIR[i]/365, model)
    model <- ramp.xds::xds_solve_cohort(model, A=10, da=1)
    XH <- ramp.xds::get_XH(model, 1)
    pr_t = tail(XH$true_pr, 365); pr[i] = mean(pr_t)
    ni_t = tail(XH$ni, 365);  ni[i]= mean(ni_t)
    eir_t = tail(XH$eir, 365)*1/rbr; eir[i] = mean(eir_t)
    scaling[[i]] = list(aeir = eir_t*365, eir = eir_t, pr = pr_t, ni = ni_t)
  }

  model$outputs$eirpr <- list(aeir=365*eir, eir=eir, pr=pr, ni=ni, scaling=scaling)

  return(model)
}

#' @title Compute eir-pr scaling relationships
#' @description This function calls [xde_solve_cohort] computes average annual values for the eir, the pr, and other
#' interesting terms and returns a table. It is computed for a model of class "cohort"
#' @param model a list that defines an `ramp.xds` model generated by `xde_setup_cohort()`
#' @param N an integer
#' @param rbr the relative biting rate for a population stratum
#' @importFrom ramp.xds set_eir
#' @importFrom utils tail
#' @return **`xds`** model object
#' @export
xde_scaling_eir = function(model, N=25, rbr=1){

  aEIR = 10^seq(-1, 3, length.out=N)
  pr = ni = eir = rep(0, N)
  scaling = list()
  for(i in 1:N){
    model <- ramp.xds::set_eir(rbr*aEIR[i]/365, model)
    model <- ramp.xds::xds_solve(model, 3650, da=1)
    XH <- ramp.xds::get_XH(model, 1)
    pr_t = tail(XH$true_pr, 365); pr[i] = mean(pr_t)
    ni_t = tail(XH$ni, 365);  ni[i]= mean(ni_t)
    eir_t = tail(XH$eir, 365)*1/rbr; eir[i] = mean(eir_t)
    scaling[[i]] = list(aeir = eir_t*365, eir = eir_t, pr = pr_t, ni = ni_t)
  }

  model$outputs$eirpr <- list(aeir=365*eir, eir=eir, pr=pr, ni=ni, scaling=scaling)

  return(model)
}

#' @title Compute scaling relationships from mosquito emergence through PfPR
#' @description This function calls [xde_solve] to get the scaling
#' relationships for mosquito density over 9 factors of 10, and average annual
#' values for the eir, the pr, and other
#' interesting terms and returns a table.
#' @param model a **`ramp.xds`** model object
#' @param fac a multiplicative factor that defines the mesh on \eqn{\log \Lambda}
#' @param N an integer
#' @importFrom utils tail
#' @return **`xds`** model object
#' @export
xde_scaling_lambda = function(model, fac=1.2, N=30){

  # get R0
  thresh <- compute_threshold(model)
  factor = c(1/100,3/100,1/10,1/5,1/2,2/3,4/5, 9/10, .95, .98, 1, 1.01, 1.02, 1.04, 1.08, 1.12, 1.2, 1.5, 2, 4, 8, 16, 32, 64, 128)
  #ff = function(n){(1.01 + 0.02*n)^n}
  #vv =  ff(1:16)
  #factor = c(1/ff(seq(12, 2, by=-2)), 1, vv)
  N = length(factor)

  # setup
  M = rep(0, N)
  pr = rep(0, N)
  ni = rep(0, N)
  eir = rep(0, N)
  scaling = list()

  model0=model
  for(i in 1:N){
    model <- model0
    # Run it for awhile
    model$Lpar[[1]]$Lambda <- thresh*factor[i]
    model <- ramp.xds::xds_solve(model, Tmax=7300, dt=7300)
    model <- last_to_inits(model)
    model <- ramp.xds::xds_solve(model, Tmax=3*365, dt=1)
    average_PR_true(model) -> pr_t; pr_t <- tail(pr_t, 365)
    pr[i] <- mean(pr_t)
    average_EIR(model) -> eir_t; eir_t <- tail(eir_t, 365)
    eir[i] <- mean(eir_t)
    MYZ <- get_MYZ(model)
    if(model$nPatches==1) M_t <- MYZ$M
    if(model$nPatches>1) M_t <- colSums(MYZ$M);
    M_t <- tail(M_t, 365)
    M[i] <- mean(M_t)
    XH <- get_XH(model)
    ni_t = tail(XH$ni, 365);  ni[i]= mean(ni_t)
    scaling[[i]] = list(Lambda = thresh*factor[i], aeir = eir_t*365, M = M_t, eir = eir_t, pr = pr_t, ni = ni_t)
  }
  Lambda <- thresh*factor
  lambda <- Lambda/get_H(model)
  model$outputs$eirpr <- list(Ro=factor, Lambda = Lambda, lambda=lambda, aeir=365*eir, eir=eir, M=M, pr=pr, ni=ni, scaling=scaling)

  return(model)
}

#' @title Get High/Low Values for Lambda
#' @param model a **`ramp.xds`** model object
#' @return a pair of values
#' @export
compute_threshold = function(model){
  model <- xds_solve(model, 3650, 3650)
  y <- get_last(model)
  b <- F_b(y,model,1)
  f <- get_f(model, 1)
  q <- get_q(model, 1)
  g <- get_g(model, 1)
  eip <- model$MYZpar[[1]]$eip
  VC <- f^2*q^2/g^2*exp(-g*eip)
  H <- get_H(model)
  D <- HTC(model, 1)
  R <- b*VC*D/H
  return(1/R)
}

#' @title Set up the MYZss object for `xde_scaling_lambda`
#' @description This function computes several quantities that are require
#' @param model a list that defines an `ramp.xds` model (*e.g.*,  generated by `xds_setup()`)
#' @export
ssMYZ = function(model){with(model$MYZpar,{
  MYZss = list()
  Omega = make_Omega_xde(g, sigma, mu, calK)
  MYZss$Omega = Omega
  MYZss$OmegaInv = solve(Omega)
  MYZss$Upsilon = expm(-Omega*eip)
  MYZss$UpsilonInv = expm(Omega*eip)
  beta = with(model$Hpar[[1]], compute_beta(H, wts_f, TaR))
  MYZss$beta = beta
  MYZss$betaInv = solve(beta)
  MYZss$f = f
  MYZss$q = q
  MYZss$g = g
  MYZss$eip = eip
  model$MYZss = MYZss
  return(model)
})}

#' @title Construct an eirpr object for an arbitary model
#' @description This takes a model and uses the XH component to define
#' the eirpr relationship using `xde_scaling_eir` then calls `xde_scaling_lambda`
#' @param model a list that defines an `ramp.xds` model (*e.g.*,  generated by `xde_setup()`)
#' @param N the size of the mesh on aEIR
#' @param F_eir a function to compute the EIR as a function of time
#' @export
xde_scaling = function(model, N=25, F_eir=NULL){
  if(is.null(F_eir)) F_eir <- function(t, pars){0*t + 1}
  mod0 = ramp.xds::xds_setup_cohort("mod0", F_eir)
  mod0$Xpar <- model$Xpar
  mod0$Hpar <- model$Hpar
  model$outputs$eirpr = xde_scaling_eir(mod0, N)$outputs$eirpr
  model <- ssMYZ(model)
  model <- pr2Lambda(model)
  return(model)
}

#' @title Using the eirpr matrix and a RM model, convert pr to Lambda
#' @description This takes a model and uses the XH component to define
#' the eirpr relationship using `xde_scaling_eir` then calls `xde_scaling_lambda`
#' @param pr a vector
#' @param model a list that defines an `ramp.xds` model (*e.g.*,  generated by `xde_setup()`)
#' @param constrain a logical, if TRUE then set all negative values to zero
#' @export
pr2Lambda = function(pr, model, constrain=TRUE){
  with(model, stopifnot(exists("MYZss")))
  with(model$MYZss,{
    eir = xde_pr2eir(pr, model, TRUE)$eir
    kappa = xde_pr2ni(pr, model, TRUE)$ni
    Z = (betaInv %*% eir)/f/q
    Y = OmegaInv %*% (UpsilonInv %*% (Omega %*% Z))
    M = diag(1/f/q/kappa, model$nPatches)%*%(diag(f*q*kappa, model$nPatches) + Omega) %*% Y
    Lambda = Omega %*% M
    if(constrain == TRUE) Lambda = pmax(Lambda,0)
    return(Lambda)
  })
}
