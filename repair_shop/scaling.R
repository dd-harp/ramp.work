
#' @title Set up the MYZss object for `xde_scaling_lambda`
#' @description This function computes several quantities that are require
#' @param xds_obj a list that defines an `ramp.xds` xds_obj (*e.g.*,  generated by `xds_setup()`)
#' @export
ssMYZ = function(xds_obj){with(xds_obj$MY_obj,{
  MYZss = list()
  Omega = make_Omega_xde(g, sigma, mu, calK)
  MYZss$Omega = Omega
  MYZss$OmegaInv = solve(Omega)
  MYZss$Upsilon = expm(-Omega*eip)
  MYZss$UpsilonInv = expm(Omega*eip)
  beta = with(xds_obj$Hpar[[1]], compute_beta(H, wts_f, TaR))
  MYZss$beta = beta
  MYZss$betaInv = solve(beta)
  MYZss$f = f
  MYZss$q = q
  MYZss$g = g
  MYZss$eip = eip
  xds_obj$MYZss = MYZss
  return(xds_obj)
})}

#' @title Construct an eirpr object for an arbitary xds_obj
#' @description This takes a xds_obj and uses the XH component to define
#' the eirpr relationship using `xde_scaling_eir` then calls `xde_scaling_lambda`
#' @param xds_obj a list that defines an `ramp.xds` xds_obj (*e.g.*,  generated by `xde_setup()`)
#' @param N the size of the mesh on aEIR
#' @param F_eir a function to compute the EIR as a function of time
#' @export
xde_scaling = function(xds_obj, N=25, F_eir=NULL){
  if(is.null(F_eir)) F_eir <- function(t, pars){0*t + 1}
  mod0 = ramp.xds::xds_setup_cohort("mod0", F_eir)
  mod0$XH_obj <- xds_obj$XH_obj
  xds_obj$outputs$eirpr = xde_scaling_eir(mod0, N)$outputs$eirpr
  xds_obj <- ssMYZ(xds_obj)
  xds_obj <- pr2Lambda(xds_obj)
  return(xds_obj)
}
